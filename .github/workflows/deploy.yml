name: Deploy to AWS Lightsail

on:
  push:
    branches: [main]
    paths-ignore:
      - "terraform/**"
      - "docs/**"
      - "*.md"
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.prod
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

  deploy:
    needs: build
    runs-on: ubuntu-latest

    defaults:
      run:
        working-directory: terraform

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~1.6"
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Initialize Terraform
        run: terraform init

      - name: Get infrastructure info from Terraform state
        id: terraform-outputs
        run: |
          echo "üîç Fetching infrastructure info from Terraform state..."

          # Get outputs from Terraform state
          HOST_IP=$(terraform output -raw static_ip)
          INSTANCE_NAME=$(terraform output -raw instance_name)
          SSH_USERNAME=$(terraform output -raw instance_username)

          # Validate outputs
          if [[ -z "$HOST_IP" || "$HOST_IP" == "null" ]]; then
            echo "‚ùå Could not get static IP from Terraform state"
            echo "üí° Make sure Terraform infrastructure is deployed first"
            exit 1
          fi

          echo "‚úÖ Retrieved infrastructure info:"
          echo "   Host IP: $HOST_IP"
          echo "   Instance: $INSTANCE_NAME"
          echo "   SSH User: $SSH_USERNAME"

          # Set outputs for subsequent steps
          echo "host-ip=$HOST_IP" >> $GITHUB_OUTPUT
          echo "instance-name=$INSTANCE_NAME" >> $GITHUB_OUTPUT
          echo "ssh-username=$SSH_USERNAME" >> $GITHUB_OUTPUT

      - name: Get SSH private key from Terraform state
        id: ssh-key
        run: |
          echo "üîë Extracting SSH private key from Terraform state..."

          # Extract private key and save to file
          terraform output -raw private_key > /tmp/ssh-key.pem
          chmod 600 /tmp/ssh-key.pem

          # Validate key file
          if [[ ! -s /tmp/ssh-key.pem ]]; then
            echo "‚ùå SSH private key is empty or missing"
            exit 1
          fi

          echo "‚úÖ SSH private key extracted successfully"
          echo "ssh-key-path=/tmp/ssh-key.pem" >> $GITHUB_OUTPUT

      - name: Test SSH connectivity
        env:
          HOST_IP: ${{ steps.terraform-outputs.outputs.host-ip }}
          SSH_KEY_PATH: ${{ steps.ssh-key.outputs.ssh-key-path }}
          SSH_USERNAME: ${{ steps.terraform-outputs.outputs.ssh-username }}
        run: |
          echo "üîå Testing SSH connectivity to ${HOST_IP}..."

          # Configure SSH
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "Host *" > ~/.ssh/config
          echo "  StrictHostKeyChecking no" >> ~/.ssh/config
          echo "  UserKnownHostsFile /dev/null" >> ~/.ssh/config
          echo "  ConnectTimeout 30" >> ~/.ssh/config
          echo "  ServerAliveInterval 60" >> ~/.ssh/config
          chmod 600 ~/.ssh/config

          # Test network connectivity first (non-fatal since ICMP might be blocked)
          echo "üì° Testing network connectivity..."
          if ping -c 3 ${HOST_IP} >/dev/null 2>&1; then
            echo "‚úÖ Host responds to ping"
          else
            echo "‚ö†Ô∏è  Host doesn't respond to ping (normal - ICMP likely blocked by AWS)"
          fi

          # Test SSH port (non-fatal since nc might not work but SSH might)
          echo "üîê Testing SSH port..."
          if nc -zv ${HOST_IP} 22 >/dev/null 2>&1; then
            echo "‚úÖ SSH port 22 is accessible"
          else
            echo "‚ö†Ô∏è  SSH port test inconclusive, will try direct SSH connection"
          fi

          # Test SSH connection with retries - this is the real test
          echo "üîë Testing SSH authentication..."
          for i in {1..15}; do
            echo "   SSH attempt $i/15..."
            if ssh -i ${SSH_KEY_PATH} -o BatchMode=yes -o ConnectTimeout=15 ${SSH_USERNAME}@${HOST_IP} "echo 'SSH connection successful'; uptime" 2>/dev/null; then
              echo "‚úÖ SSH connection established successfully"
              break
            fi

            if [ $i -eq 15 ]; then
              echo "‚ùå SSH connection failed after 15 attempts"
              echo "üîç Debugging information:"
              echo "   Host: ${HOST_IP}"
              echo "   User: ${SSH_USERNAME}"
              echo "   Key: ${SSH_KEY_PATH}"

              # Show SSH key fingerprint for debugging
              echo "üîç SSH key fingerprint:"
              ssh-keygen -lf ${SSH_KEY_PATH} || echo "Could not get key fingerprint"

              # Try verbose SSH for debugging
              echo "üîç Verbose SSH attempt (last try):"
              ssh -i ${SSH_KEY_PATH} -vvv -o BatchMode=yes -o ConnectTimeout=15 ${SSH_USERNAME}@${HOST_IP} "echo 'test'" || true
              exit 1
            fi

            sleep 20
          done

      - name: Deploy to Lightsail
        env:
          HOST_IP: ${{ steps.terraform-outputs.outputs.host-ip }}
          SSH_KEY_PATH: ${{ steps.ssh-key.outputs.ssh-key-path }}
          SSH_USERNAME: ${{ steps.terraform-outputs.outputs.ssh-username }}
          DOCKER_IMAGE: ${{ needs.build.outputs.image-tag }}
          POSTGRES_HOST: ${{ secrets.POSTGRES_HOST }}
          POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
        working-directory: .
        run: |
          # Extract first image tag
          IMAGE_TAG=$(echo "${DOCKER_IMAGE}" | head -n1)
          echo "üö¢ Deploying image: ${IMAGE_TAG}"

          # Ensure directory exists
          ssh -i ${SSH_KEY_PATH} ${SSH_USERNAME}@${HOST_IP} "sudo mkdir -p /opt/expense-tracker && sudo chown ${SSH_USERNAME}:${SSH_USERNAME} /opt/expense-tracker"

          # Copy files to server
          echo "üìÅ Copying deployment files..."
          scp -i ${SSH_KEY_PATH} docker-compose.prod.yml ${SSH_USERNAME}@${HOST_IP}:/opt/expense-tracker/docker-compose.yml
          scp -i ${SSH_KEY_PATH} deploy.sh ${SSH_USERNAME}@${HOST_IP}:/opt/expense-tracker/deploy.sh

          # Execute deployment
          echo "üöÄ Executing deployment..."
          ssh -i ${SSH_KEY_PATH} ${SSH_USERNAME}@${HOST_IP} "cd /opt/expense-tracker && chmod +x deploy.sh && \
            DOCKER_IMAGE='${IMAGE_TAG}' \
            POSTGRES_HOST='${POSTGRES_HOST}' \
            POSTGRES_PORT='${POSTGRES_PORT}' \
            POSTGRES_DB='${POSTGRES_DB}' \
            POSTGRES_USER='${POSTGRES_USER}' \
            POSTGRES_PASSWORD='${POSTGRES_PASSWORD}' \
            TELEGRAM_BOT_TOKEN='${TELEGRAM_BOT_TOKEN}' \
            OPENAI_API_KEY='${OPENAI_API_KEY}' \
            GITHUB_TOKEN='${GITHUB_TOKEN}' \
            GITHUB_ACTOR='${GITHUB_ACTOR}' \
            ./deploy.sh"

      - name: Verify deployment
        env:
          HOST_IP: ${{ steps.terraform-outputs.outputs.host-ip }}
        run: |
          # Wait a moment for the service to fully start
          sleep 30

          # Check if the health endpoint responds
          echo "üè• Testing health endpoint..."
          if curl -f http://${HOST_IP}:8000/health; then
            echo "‚úÖ Deployment successful - health check passed"
          else
            echo "‚ùå Deployment failed - health check failed"

            # Get some debugging info
            echo "üîç Debugging deployment failure..."
            ssh -i ${{ steps.ssh-key.outputs.ssh-key-path }} ${{ steps.terraform-outputs.outputs.ssh-username }}@${HOST_IP} "cd /opt/expense-tracker && docker-compose ps && docker-compose logs --tail=50" || true

            exit 1
          fi

      - name: Notify deployment status
        env:
          HOST_IP: ${{ steps.terraform-outputs.outputs.host-ip }}
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "üöÄ Deployment to Lightsail completed successfully!"
            echo "üîó Health check: http://${HOST_IP}:8000/health"
            echo "üìä Instance: ${{ steps.terraform-outputs.outputs.instance-name }}"
          else
            echo "üí• Deployment failed!"
            echo "üîç Check the logs above for debugging information"
          fi
